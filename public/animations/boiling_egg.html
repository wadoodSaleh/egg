<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Boiling Egg Animation</title>
  <style>
    body {
      margin: 0;
      background: #FDF0C3;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }

    canvas {
      /* keep canvas square and scale to viewport without cropping */
      width: min(80vmin, 512px);
      aspect-ratio: 1/1;
      image-rendering: pixelated;
      display: block;
      background: transparent;
      max-width: 100%;
      max-height: 100%;
    }
  </style>
</head>
<body>

<canvas id="egg" width="128" height="128"></canvas>

<script>
// Canvas setup
const canvas = document.getElementById("egg");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

// State
let cookLevel = 0;

// Image assets
const images = {};
const ASSETS = [
  "boiled_white.png",
  "boiled_yolk.png",
  "face_sleepy.png",
  "face_happy.png",
  "face_hard.png",
  "face_sad.png",
  "face_scream.png"
];

// Load all assets
loadAssets().then(() => {
  loop();
});

function loadAssets() {
  return Promise.all(
    ASSETS.map(src => new Promise(res => {
      const img = new Image();
      img.src = `/${src}`;
      img.onload = () => {
        images[src] = img;
        // Also expose without .png extension for easier access
        const key = src.replace('.png', '');
        images[key] = img;
        res();
      };
      img.onerror = () => res(); // Allow missing images
    }))
  );
}

// Define cooking stages
const STAGES = [
  { max: 0.25, name: "soft-boiled", face: "sleepy" },
  { max: 0.45, name: "hard-boiled", face: "happy" },
  { max: 0.725, name: "overcooked-mid", face: "hard" },
  { max: 0.95, name: "burnt-start", face: "sad" },
  { max: 1.0, name: "burnt", face: "scream" }
];

function getStage(level) {
  return STAGES.find(s => level <= s.max);
}

function drawEgg(level) {
  ctx.clearRect(0, 0, 128, 128);

  // Calculate white opacity (0 to 1 as it reaches soft-boiled)
  const whiteOpacity = Math.min(level / 0.25, 1);
  
  // Calculate brown hue for overcooked (starts after hard-boiled at 0.45)
  let brownAmount = 0;
  if (level > 0.45) {
    brownAmount = Math.min((level - 0.45) / 0.55, 1);
  }

  // Draw white with opacity and brown tint
  drawBoiledWhite(whiteOpacity, brownAmount);
  
  // Draw yolk with color transition
  drawBoiledYolk(level);

  // Draw face on top
  const stage = getStage(level);
  drawFace(stage.face);
}

function drawBoiledWhite(opacity, brownAmount) {
  if (!images.boiled_white) return;
  
  ctx.save();
  
  // Draw the white image with opacity
  ctx.globalAlpha = opacity;
  ctx.drawImage(images.boiled_white, 0, 0, 128, 128);
  
  // Apply brown tint for overcooked state using source-atop
  if (brownAmount > 0) {
    ctx.globalCompositeOperation = "source-atop";
    
    // Create a lighter brown gradient overlay (less intense than before)
    const brownValue = Math.floor(220 - (35 * brownAmount)); // lighter base color
    const gradient = ctx.createRadialGradient(64, 64, 20, 64, 64, 50);
    gradient.addColorStop(0, `rgba(${brownValue + 30}, ${brownValue}, ${Math.max(brownValue - 50,0)}, 0)`);
    // Reduce alpha multiplier so the tint is subtler
    gradient.addColorStop(1, `rgba(${brownValue}, ${Math.max(brownValue - 20,0)}, ${Math.max(brownValue - 70,0)}, ${brownAmount * 0.4})`);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);
  }
  
  ctx.restore();
}

function drawBoiledYolk(level) {
  if (!images.boiled_yolk) return;
  
  ctx.save();
  
  // Draw the yolk image
  ctx.drawImage(images.boiled_yolk, 0, 0, 128, 128);
  
  // Make yolk turn lighter yellow between soft-boiled (0.25) and hard-boiled (0.45)
  const yellowStart = 0.25;
  const yellowEnd = 0.45;
  const yellowProgress = Math.min(Math.max((level - yellowStart) / (yellowEnd - yellowStart), 0), 1);
  if (yellowProgress > 0) {
    // Clip to a yolk-shaped circle so the tint only affects the yolk
    ctx.save();
    ctx.beginPath();
    ctx.arc(64, 64, 28, 0, Math.PI * 2);
    ctx.clip();

    ctx.globalCompositeOperation = "source-atop";
    const r = 255, g = 230, b = 100; // target light yellow
    const grad = ctx.createRadialGradient(64, 64, 6, 64, 64, 28);
    grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${yellowProgress * 0.9})`);
    grad.addColorStop(1, `rgba(${Math.max(r-30,0)}, ${Math.max(g-60,0)}, ${Math.max(b-60,0)}, ${yellowProgress * 0.6})`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 128, 128);

    ctx.restore(); // remove clip
    // leave composite for any subsequent overcooked tint
  }

  // Apply color transition for overcooked state
  if (level > 0.45) {
    // Clip to yolk circle so only the yolk is tinted
    ctx.save();
    ctx.beginPath();
    ctx.arc(64, 64, 28, 0, Math.PI * 2);
    ctx.clip();

    ctx.globalCompositeOperation = "source-atop";

    const greenProgress = Math.min((level - 0.45) / 0.55, 1);

    // Gray-green at the rim: stronger at the outer edge, transparent at center
    // Use cooler green-gray RGB values for a muted effect
    const rimR = Math.floor(180 - (40 * greenProgress));
    const rimG = Math.floor(200 - (30 * greenProgress));
    const rimB = Math.floor(120 + (40 * greenProgress));

    const gradient = ctx.createRadialGradient(64, 64, 16, 64, 64, 28);
    gradient.addColorStop(0, `rgba(${rimR}, ${rimG}, ${rimB}, 0)`); // center transparent
    gradient.addColorStop(1, `rgba(${rimR - 20}, ${rimG - 30}, ${rimB - 10}, ${greenProgress * 0.9})`); // rim colored

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 128, 128);

    ctx.restore();
  }
  
  ctx.restore();
}

function drawFace(faceType) {
  const faceKey = `face_${faceType}`;
  
  // Try to use image first
  if (images[faceKey]) {
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(images[faceKey], 0, 0, 128, 128);
    ctx.restore();
    return;
  }

  // Fallback to drawn face
  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  ctx.translate(64, 64);
  ctx.fillStyle = "#000";

  // Eyes
  drawPixel(-6, -4);
  drawPixel(6, -4);

  // Mouth based on face type
  switch (faceType) {
    case "sleepy":
      drawLine(-4, 4, 4, 4);
      break;
    case "happy":
      drawLine(-4, 3, -2, 5);
      drawLine(-2, 5, 2, 5);
      drawLine(2, 5, 4, 3);
      break;
    case "hard":
      drawLine(-3, 4, 3, 4);
      break;
    case "sad":
      drawLine(-4, 6, -2, 4);
      drawLine(-2, 4, 2, 4);
      drawLine(2, 4, 4, 6);
      break;
    case "scream":
      ctx.fillRect(-2, 2, 4, 6);
      break;
  }

  ctx.restore();
}

function drawPixel(x, y) {
  ctx.fillRect(x, y, 2, 2);
}

function drawLine(x1, y1, x2, y2) {
  const dx = Math.sign(x2 - x1) * 2;
  const dy = Math.sign(y2 - y1) * 2;
  let x = x1, y = y1;

  while (Math.abs(x - x2) > 1 || Math.abs(y - y2) > 1) {
    drawPixel(x, y);
    if (Math.abs(x - x2) > 1) x += dx;
    if (Math.abs(y - y2) > 1) y += dy;
  }
  drawPixel(x2, y2);
}

function loop() {
  drawEgg(cookLevel);
  requestAnimationFrame(loop);
}

// Expose function for parent timer to control burn level
window.setBurnLevel = function(level) {
  cookLevel = Math.max(0, Math.min(1, level));
};

// Start animation if images are already loaded
if (Object.keys(images).length > 0) {
  loop();
}
</script>

</body>
</html>